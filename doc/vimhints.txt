*vimhints.txt* My hints for Vim...                              *vimhints*
==============================================================================

h, j, k, l      - left, down, up, right motions, respectively
gj, gk          - down, up motions by display line, respectively
CTRL-W {motion} - switch to splitscreen buffer in direction of MOTION
CTRL-W CTRL-W   - switch between open windows in sequence (or: CTRL-W w)
f0, F0          - jump to next/previous occurence of 0, respectively
p, P            - paste after/before, respectively
<C-X><C-...>    - for completions (INSERT MODE) (see completion below)

NOTABLE CUSTOM MAPPINGS:
,ss     - toggle spell-check
,ww     - toggle line-wrap
,hh     - turn off search highlighting until next search
,fo     - open all folds
,fc     - close all folds
,uu     - underline current line for a Markdown header with -
,u-     - underline current line for a Markdown header with -
,u=     - underline current line for a Markdown header with =

NOTABLE PLUGINS:
gcc     - toggle commenting [|commentary|]
-       - in normal mode: open netrw [|vinegar|]
-       - in a netrw buffer: go to parent directory [|vinegar|]

NOTABLE MISC:
%       - jump to the matching parenthesis or brackets
:37     - jump to line 37
79|     - jump to the 79th column
C       - chop off (change) end of line and go into insert mode.
*       - searches for the word under the cursor
=       - fixes indentation of the selected text
yy      - copy current line
dd      - cut current line
gqq     - format current line to 80 columns
za      - toggle current fold
CTRL-]  - follow a link
CTRL-T  - goes back from a link


------------------------------------------------------------------------------
Table of contents:               (hit CTRL-] to follow a link)
------------------------------------------------------------------------------
1. Movement                     |vimhints_movement|
2. Editing                      |vimhints_editing|
3. Searching                    |vimhints_searching|
4. Splits/Tabs/Windows          |vimhints_splits_tabs_windows|
5. Plugins                      |vimhints_plugins|
6. Miscelaneous or Unsorted     |vimhints_misc|

------------------------------------------------------------------------------
How to format this file:

  - anchors:            surround words w/ *
  - links:              surround words w/ |
  - options/params:     'option'
  - commands:           "command"
  - URLs:               automatically higlighted
  - control key combos: CTRL-A , <CTRL-A> or <C-A>
  - use {motion} to indicate motion in a command like V{motion}
  - highlight the whole line by addding a tilde at the end ~
  - indented blocks on lines after a line terminating in a '>' will be
    highlighted
  - to turn of highlighted indented block after a '>' use a '<' or use
    an unindented line

==============================================================================
1. Movement                                             *vimhints_movement*
------------------------------------------------------------------------------

Left: >
  h
Right: >
  l
Down: >
  j
Up: >
  k

Start of next word (aka forward a word): >
  w
End of current word: >
  e
Beginning of previous word (aka back a word): >
  b

Next sentence: >
  )
Previous sentence: >
  (

End of line: >
  $
Start of line: >
  0
< or: >
  ^

Start of file: >
  gg
End of file: >
  G
Arbitrary line number 24: >
  24G (or 24gg)
Arbitrary line number 24 (other method): >
  :24

Go to the complementary character (when over a ( ) [ ] { } char)
[Pressing % when over a '{' will go to the '}' that matches it.]: >
  %

go 1/2 a page down: >
  <C-d>
go 1/2 a page up: >
  <C-u>

Jump 50 percent through file: >
  50%
Jump 15 percent through file: >
  15%
(There is no "0%" command available. use "gg" instead.)

Move down by a display line, when the text is wrapped: >
  gj
< or: >
  g<down>
Move up by a display line, when the text is wrapped: >
  gk
< or: >
  g<up>

Jump to next <char> on line: >
  f<char>
Jump to just before the next <char> on line: >
  t<char>
Repeat last f<char> command: >
  ;
Jump to previous <char> on line: >
  F<char>

Paste and match indenting of block: >
  ]p

aw        - a word
iw        - inner word
aw        - a word
iW        - inner WORD
as        - a sentence
is        - inner sentence
ap        - a paragraph
ip        - inner paragraph
a] a[     - a [] block
i] i[     - inner [] block
a) a( ab  - a block
i) i( ib  - inner block
a> a<     - a <> block
i> i<     - inner <> block
at        - a tag block (ie. "<aaa>" to "</aaa>", including tags)
it        - inner tag block (excluding the tags)
a} a{ aB  - a Block
i} i{ iB  - inner Block
a" a' a`  - a quoted string, including the quote marks 
i" i' i`  - inner quoted string, excluding the quote marks



==============================================================================
2. Editing                                              *vimhints_editing*
------------------------------------------------------------------------------

Delete character under cursor: >
  x

Enter insert mode before current character: >
  i
Move to beginning of line and enter insert mode: >
  I
Enter insert mode after current character: >
  a
Move to end of line and enter insert mode: >
  A

Replace character under cursor with arbitrary x (enter Insert-mode for just one
char then go back to Normal-mode): >
  rx

Replace 5 characters with arbitrary string '34567' starting under cursor (enter
Insert-mode and start overwriting): >
  R34567

Change until end of word (delete until end of word and enter insert mode): >
  ce

Change until end of line (delete until end of line and enter insert mode): >
  c$
< or: >
  C     (capital C)

Show your location in the file and the file status: >
  <C-g>

Retrieve (merge) arbitrary file 'test.txt' into current buffer: >
  :r test.txt
Retrieve (merge) result of arbitrary shell command 'ls' into current buffer: >
  :r !ls

Enter visual mode and select text
[Actions can be performed upon selection like 'd' to delete it, or ':w FILENAME'
to save it to FILENAME]: >
  v MOTION  (where MOTION is some arbitrary movement command)
Enter visual mode and select text BY LINE: >
  V MOTION  (uppercase V)
Enter visual mode and select text BY RECTANGLE/BLOCK: >
  <C-v> MOTION

open a new line below the cursor and place you in Insert mode: >
  o   (lowercase o)
open a new line above the cursor and place you in Insert mode: >
  O   (uppercase o)

Copy text (visual-mode): >
  v (to open vis-mode) [select text] y (to copy it and leave vis-mode)

Copy one word (normal-mode)
[you can use any movement operator with this, like y2w or yj or y$]: >
  yw

Make word uppercase: >
  gUiw
Make selection in visual mode lowercase: >
  gu
Make current line all lowercase: >
  guu
Make current line all uppercase: >
  gUU
Invert case of current character: >
  ~

Reverse next two characters: >
  xp


==============================================================================
3. Searching                                            *vimhints_searching*
------------------------------------------------------------------------------

NOTE: Search uses regular expressions (regex)

Search for string 'term': >
  /term

Change the first occurance of string 'old' to 'new' in current line: >
  :s/old/new <ENTER>
Change every occurance of string 'old' to 'new' in current line: >
  :s/old/new/g
Change every occurance of string 'old' to 'new' between lines 2 and 9: >
  :2,9s/old/new/g
Change every occurance of string 'old' to 'new' in the whole file: >
  :%s/old/new/g 
Change every occurance of string 'old' to 'new' in the whole file, with a prompt: >
  :%s/old/new/gc

Add 'suffix' to the end of every line (1 is line 1, $ is the last line): >
  :1,$ s/$/suffix/
< or: >
  :%s/$/suffix/

Add 'prefix' to the start of lines 5-10: >
  :5,10 s/^/prefix/

Search “the”, “theatre” or “then”: >
  /\<the
Search “the” or “breathe”: >
  /the\>
Search “the” (whole word, and only that word): >
  /\<the\>

Search in all open files: >
  :bufdo /searchstr/

Match lines with either "foo" or "beep": >
  /foo\|beep 
Match lines with both "Peter" and "Bob": >
  /.*Peter\&.*Bob 

Delete all lines containing “string”: >
  :g/string/d
Delete all lines which didn't contain “string”: >
  :v/string/d
Delete lines which appears twice in a row: >
  :%s/^\(.*\)\n\1$/\1/
Delete lines that only have whitespace: >
  :g/^\s*$/d
Delete blank lines: >
  :v/./d or :g/^$/d
Replace multiple consecutive blank lines with one blank line: >
  :v/./.,/./-1join

Delete DOS carriage returns (^M): >
  :%s/\r//g
Transform DOS carriage returns to returns: >
  :%s/\r/\r/g

Delete HTML tags but keeps text: >
  :%s#<[^>]\+>##g

Delete blanks from end of lines: >
  :%s/\s*$//
Remove the first 30 characters from each line: >
  :%s/^.\{30}//

Convert the entire file to lowercase: >
  :%s/.*/\L&/
Convert the first character of line to uppercase: >
  :s/.*/\u&/
Convert the first character of each word to uppercase: >
  :%s/\<./\u&/g

Repeat previous substitution: >
  :&

Convert a line like 'Last, First' to 'First Last': >
  :%s/\([^,]*\), \(.*$\)/\2 \1/
Convert a line like 'Artist - Song' to '"Song" - Artist': >
  :%s/\(^.*\) - \(.*$\)/"\2" - \1/


==============================================================================
4. Splits/Tabs/Windows                         *vimhints_splits_tabs_windows*
------------------------------------------------------------------------------

(I use the terms 'split' and 'window' somewhat interchangably. Vim doesn't
really have any interactions between true windows (since that's a GUI
implementation, not a Vim thing) so there aren't any notes about true windows.)

Switch to window in direction h (or j, or k, or l): >
  <C-w> h       (or j, or k, or l)

Switch between open windows in sequence: >
  <C-w w>
< or: >
  <C-w> <C-w>

horizontal split of current window: >
  <C-w> s
< or: >
  :split
< or: >
  :sp
new horizontal split window: >
  <C-w> n
< or: >
  :new
vertical split of current window: >
  <C-w> v
< or: >
  :vsplit
< or: >
  :vs
new vertical split window: >
  :vnew
< or: >
  :vne
quit/close a window: >
  <C-w> q
< or: >
  :q

Make the current window the only one on the screen.  All other windows are closed: >
  <C-w> o
< or: >
  :only
< or: >
  :on

make all windows fairly equally sized: >
  <C-w> =
decrease height of current window: >
  <C-w> -  (dash)
increase height of current window: >
  <C-w> +
increase height of current window to the max: >
  <C-w> _  (underscore)

decrease width of current window: >
  <C-w> <
increase width of current window: >
  <C-w> >
increase width of current window to the max: >
  <C-w> |  (pipe)

Make a horizontal split be a vertical split: >
  <C-w>H
Make a vertical split be a horizontal split: >
  <C-w>K
(Might need to do <C-w>t <C-w>K or <C-w>t <C-w>H in the above switches, maybe.)

The following commands open the file name under the cursor:
  gf    open in the same window ("goto file")
  <c-w>f    open in a new window
  <c-w>gf    open in a new tab 
You can return to the previous buffer using Ctrl-^ or Ctrl-o.

To open the help in its own tab: >
   :tab help SOME_TOPIC_TO_FIND


:vnew
make a new vsplit with an empty buffer

<C-w>r
rotate the splits (when you only have two, it swaps them)


==============================================================================
5. Plugins                                              *vimhints_plugins*
------------------------------------------------------------------------------

pathogen:
--------------
Run helptags via pathogen (for bundles) [|pathogen|]: >
  :call pathogen#helptags()
Run helptags via pathogen (for bundles) [|pathogen|]: >
  :Helptags

Update a bundle from a git repo [|pathogen|]: >
  1. cd ~/path/to/bundle
  2. git pull origin master

Install vimball in bundle dir [|pathogen|]: >
  1. Open vimball like normal (vim vimball.vba)
  2. :UseVimball ~/path/to/extract/to

Disable a bundle so it's not loaded by pathogen [|pathogen|]: >
  1. Append ~ at the end of the bundle directory name

"You can also pass an absolute path instead. I keep the plugins I maintain under ~/src, and this is how I add them:
  execute pathogen#infect('bundle/{}', '~/src/vim/bundle/{}')
"
-- building off this, maybe put non-repo bundles into vim/bundle-misc ??


vinegar:
----------------
Show netrw anytime in normal mode [|vinegar|]: >
  -

Within netrw, go up a directory [|vinegar|]: >
  -
Within netrw, go to the home directory [|vinegar|]: >
  ~

Within netrw, toggle the helptext at top [|vinegar|]: >
  I
Within netrw, show the .. and . dirs [|vinegar|]: >
  a

Within netrw, :cd to the currently edited directory [|vinegar|]: >
  cg
Within netrw, :lcd to the currently edited directory [|vinegar|]: >
  cl


netrw:
--------------
Within netrw, return (exit) to the last buffer [|netrw|]: >
  <C-^>  (or <C-6>)

Open netrw in a leftside split that stays there [|netrw|]: >
  :Lexplore
< or, for short: >
  :Lex
Open netrw in a 30-char wide leftside split that stays there [|netrw|]: >
  :30Lex

Open netrw in current buffer [|netrw|]: >
  :Ex

Within netrw, to switch how the files are listed [|netrw|]: >
  i
(it cycles through a few, one of which is tree view!)

Within netrw, open a file in a vertical split [|netrw|]: >
  v


netrw has a "tree view" listing that is set to default as follows:
  let g:netrw_liststyle = 3

What if I make my ,nn mapping do:
  let g:netrw_liststyle = 3
  30Lex
?
issue: then I'd need a let g:netrw_liststyle = 0 in vinegar's - mapping?
issue: might not toggle, so much as just open it?

Since I have the netrw plugin installed, you can open stuff via network.
For instance, to view/edit the source of a webpage:
vim http://www.google.com
(or, while in Vim:)
:e http://www.google.com
(This will also work with FTP, SFTP, and others. See :h netrw)


fugitive:
---------------

Opens a split showing the results of 'git status' [|fugitive|]: >
  :Gstatus
< or: >
  :Gst

Do a :w and 'git add' (when run on a normal file) [|fugitive|]: >
  :Gwrite
< or: >
  :Gw

Open split to write git commit msg (unless used with '-m "message"') [|fugitive|]: >
  :Gcommit
< or: >
  :Gcom

Git vimdiff the current file staged (left) vs unstaged (right) [|fugitive|]: >
  :Gdiff
Git vimdiff current file against revision (newer on right side) [|fugitive|]: >
  :Gdiff [revision]

Do a 'git mv' or 'git rm' respectively [|fugitive|]: >
  :Gmove {destination}
  :Gremove

:edit, :split, or :tabedit a git revision [|fugitive|]: >
  :Gedit [revision]
  :Gsplit [revision]
  :Gtabedit [revision]

Run any git command, as if it were a command line (ie. ':Git st') [|fugitive|]: >
  :Git [arg]




comentary:
---------------
Toggle comment on current line [|commentary|]: >
  gcc

Toggle comment on a region defined by a motion [|commentary|]: >
  gc{MOTION}
For example, comment out a paragraph [|commentary|]: >
  gcap

Toggle comment on a visual selection [|commentary|]: >
  gc


==============================================================================
6. Miscelaneous or Unsorted                             *vimhints_misc*
------------------------------------------------------------------------------

Follow a tag link (like in a help file): >
  CTRL-]
Go to older position in tag stack (effectively goes back from a link): >
  CTRL-T

Go to older position in jump list: >
  CTRL-O
Go to newer position in jump list: >
  CTRL-I

Execute arbitrary shell command 'ls' and display result: >
  :!ls

Start a game of tetris (plugin): >
  \te

Reverse next two characters: >
  xp

Delete to end of page, in other words, everything visible: >
  dL

Delete until end of line: >
  D
Delete until end of line and go into insert mode: >
  C

Searches for the word under the cursor: >
  *

Indents the selected text: >
  =

Give you a file exploring pane above the buffer you are currently using: >
  :Sex

Same as :Sex but not in a split window: >
  :Ex
< or: >
  :e .

Re-tab selected text (like pressing =): >
  :ret

Will turn on/off hidden characters, and show end of lines: >
  :set list
  :set nolist

Toggle spacehi (space highlighter) on/off to see space problems: >
  <F3> (<Fn-F3> on my macbook keyboard)

Convert current buffer to syntax highlighted html file using current highlight scheme: >
  :TOhtml

[from command line] Pipe stdin from ls to vim: >
  ls | vim -

Insert (read) the output of shell command 'ls' into current buffer: >
  :r!ls

Filters the next 5 lines through shell command 'fmt': >
  5!!fmt
Filters the next paragraph through shell command 'fmt': >
  !}fmt
Filters the whole buffer through shell command 'fmt': >
  :%!fmt

Copy current line to OSX's clipboard: >
  :.w !pbcopy
Cut current line to OSX's clipboard: >
  :.!pbcopy
< or: >
  !!pbcopy
Cut line 4 to 8 to OSX's clipboard: >
  :4,8w !pbcopy
Cut line 4 to 8 to OSX's clipboard: >
  :4,8!pbcopy
Copy current filename to OSX's clipboard: >
  :!echo "%:p" | pbcopy
Paste OSX's clipboards content to current position in buffer: >
  :r !pbpaste

Convert to hex: >
  :%!xxd
Convert back from hex: >
  :%!xxd -r

Sort lines in buffer: >
  :sort

A simple command will highlight any text after column 80: >
  :match ErrorMsg '\%>80v.\+'
Clear previous match command: >
  :match

Write and quit (same as :wq): >
  ZZ
Quit without writing (same as :q!): >
  ZQ
Write all and quit all (same as :wqa): >
  :xa

Operate command over all buffers: >
  :bufdo %s/foo/bar/
Operate command over all windows: >
  :windo %s/foo/bar/
Operate command over all tabs: >
  :tabdo %s/foo/bar/
Operate command over *.c and *.h files (substitute uses 'e' to avoid errors
when 'foo' isn't found in one of the files): >
  :args *.[ch]
  :argdo %s/foo/bar/e | update

Reverse all lines in a file: >
  :g/^/m0
Reverse all lines in a range (last number is 1 less than start of range): >
  :50,60g/^/m49

Jump to the first 'm' in a line: >
  fm
Jump to next 'm': >
  ;
Jump to 3rd 'q' in a line: >
  3fq

Move line 30 to just after line 10 (without visual mode): >
  :30m10
Move lines 40-50 to just after line 30: >
  :40,50m30

Format lines 35-70 (without visual mode): >
  35,70=
Copy (yank) lines 14-16 (without visual mode): >
  14,16y
Delete lines 16-20 (without visual mode): >
  16,20d

See the name of the current colorscheme, if there is one: >
  :echo g:colors_name

Quickly and easily reload your vimrc: >
  :source $MYVIMRC
Show where your vimrc is: >
  :echo $MYVIMRC

Turn spell check on: >
  :set spell
Turn spell check off: >
  :set nospell
Toggle spell check (my mapping): >
  ,ss

Next spellcheck mistake: >
  ]s
Previous spellcheck mistake: >
  [s
Suggest words for current spellcheck mistake: >
  z=
Switch word for first suggestion -- like "i'm feeling lucky" spellcheck: >
  1z=

Add word to permanent spellcheck whitelist: >
  zg
Add word to temporary spellcheck whitelist -- lost when buffer closes: >
  zG

Add word to spellfile as a bad spellcheck word: >
  zw

Undo classifying a word a bad spellcheck word: >
  zuw
Undo classifying a word a good spellcheck word: >
  zug
Strip all commented lines out of spellfile (in case there are too many): >
  :runtime spell/cleanadd.vim

Set the spellcheck language to an appropriate region: >
  :set spelllang=en
  :set spelllang=en_us
  :set spelllang=en_gb



Remove empty lines: >
  :%s/^\n//

when in insert mode, insert char above current cursor position: >
  <C-y>
when in insert mode, insert char above current cursor position: >
  <C-e>

Join line below with current line (without insert mode): >
  J
Split a line at the cursor (without insert mode): >
  r<ENTER>

increment number under cursor: >
  C-a
decrement num under cursor: >
  C-x

select whole file quickly: >
  ggVG

List templates (my plugin): >
  :Templatelist
Load html template (if available) (you need to set the ft yourself): >
  :Template html

open a (single) fold: >
  zo
open a fold and all nested folds: >
  zO
close a fold (and any enclosed nested folds): >
  zc

move to next fold, whether it's open or not: >
  zj
move to previous fold, whether it's open or not: >
  zk

open all folds in the shallowest level of closed folds: >
  zr
open all folds: >
  zR
close all folds in the deepest level of open folds: >
  zm
close all folds: >
  zM

remove a fold (can not undo!): >
  zd
remove all folds (can not undo!): >
  zE

Write a file when you've forgotten to 'sudo vim' first ([L]oad when asked): >
  :w !sudo tee %

Surround plugin (for more help, type :h surround):
Delete surrounding ''s: >
  ds'
Delete surrounding ()s: >
  ds(
Delete surrounding <tag></tag>s: >
  dst

Change surrounding "s to 's: >
  cs"'
Change surrounding "s to <p></p> tags: >
  cs"<p>
Change surrounding <tag></tag>s to 's: >
  cst'

Surround the current word with "s: >
  csw"
Surround current word with ()s: >
  csw)
Surround current word with (  )s: >
  csw(

Surround inner word with "s: >
  ysiw"
Surround whole line with {}s: >
  yss}
Surround whole line with []s above and below: >
  ySS]

Vim's built in quick reference (pretty thorough for a "quick" ref): >
  :h quickref

Replace chars that are supposed to be newlines with real newlines: >
  :%s/\r/\r/g
< or: >
  :%s/^V^M/\r/g

Make MacVim fullscreen: >
  :set fuoptions=maxvert,maxhorz
  :set fullscreen
Return from fullscreen: >
  :set nofullscreen

Replaces current line with date: >
  !!date
Replace current line with the absolute path to 'command': >
  !!which 'command'
Delete a,b,c,d from the current line (case sensitive): >
  !!tr -d abcd
Replace current line with output of 'command' (general form): >
  !!command

Move cursor to top of screen (high): >
  H
Move cursor to medium of screen (mid): >
  M
Move cursor to bottom of screen (low): >
  L

Open file name under cursor: >
  gf

Delete lines matching pattern: >
  :g/.*foo.*/d
Delete lines NOT matching pattern: >
  :g!/.*foo.*/d


Display contents of all registers: >
  :reg
USEFUL REGISTER: System clipboard register: >
  *
USEFUL REGISTER: System clipboard register: >
  +
USEFUL REGISTER: Last EX command register: >
  :
USEFUL REGISTER: What was in vim's clipboard before the last yank: >
  0
USEFUL REGISTER: Last / search pattern: >
  /

Delete line into <register> (where register is a-z or 0-9): >
  "<register>dd
EXAMPLE: Delete line into register z: >
  "zdd
Paste from <register> (normal mode): >
  "<register>p
Paste from <register> (insert or command mode): >
  <C-r><register>
Insert the answer to a math expression in insert mode: >
  <C-r>=EXPRESSION         (for example, <C-r>=35*67 inserts 2345)
Insert word under cursor (command mode): >
  <C-r><C-w>

Paste from the system clipboard (normal mode): >
  "*p
< or: >
  "+p
Paste last search pattern used (normal mode): >
  "/p
Paste last command line used (normal mode): >
  ":p

Paste from the system clipboard (insert or command mode): >
  <C-r>*
< or: >
  <C-r>+
Paste last search pattern used (insert or command mode): >
  <C-r>/
Paste last command line used (insert or command mode): >
  <C-r>:
Paste last yanked/cut/copied text (insert or command mode): >
  <C-r>"


Begin recording a macro to <register> (where register is a-z or 0-9): >
  q<register>
Stop recording macro: >
  q
Replay macro from <register>: >
  @<register>
Replay last macro: >
  @@
Repeat last EX command (run macro from 'last EX command' register): >
  @:
Paste contents of a macro: >
  "<register>p
Yank visual selection into a register (ie. after edit a macro's contents): >
  "<register>y
Run a EX command from a register: >
  :@<register>
Run a EX command from the yank register: >
  :@"


Put line containing 'foo' after each line matching PATTERN: >
  :g/<PATTERN>/put ='foo'
Put blank line after each line matching PATTERN: >
  :g/<PATTERN>/put _
Put line containing 'foo' before each line matching PATTERN: >
  :g/<PATTERN>/-put ='foo'
Put blank line before each line matching PATTERN: >
  :g/<PATTERN>/-put _

Copy the entire buffer to the system clipboard: >
  :%y+

Define a search pattern manually (does not jump to result until 'n' is hit in normal mode): >
  :let @/ = 'foo'


Go to man page of word under cursor: >
  K
Go to the definition or declaration of a function or variable under cursor: >
  gd

Delete trailing whitespace: >
  s/\s\+$//

Open Safari and google for something: >
  :!google SEARCHTERM

Open FILENAME in a new split and compare the current buffer to it: >
  :diffsplit FILENAME

(diff mode) Jump forwards to the next start of a change/diff: >
  ]c
(diff mode) Jump backwards to the previous start of a change/diff: >
  [c

(diff mode) get the change from the other buffer to this buffer: >
  :diffget
< or: >
  do
(diff mode) get all diffs from the other buffer: >
  :1,$+1diffget

(diff mode) put the change in this buffer in the other buffer: >
  :diffput
< or: >
  dp

Open a cool calendar (vertical): >
  :Calendar
Open a cool calendar (horizontal): >
  :CalendarH

Insert a modeline: >
  :Modeliner

Cut around tag for xml/html tags: >
  cat
Delete in word: >
  diw
Delete text within a (): >
  di(
Delete text within a "": >
  di"

To open the help in its own tab: >
   :tab help SOME_TOPIC_TO_FIND
To open the help in the current buffer: >
   :set bt=help | help SOME_TOPIC_TO_FIND

autocomplete from the words in the current file: >
  <C-n>

Sort all lines and keeping unique lines: >
  :sort u

To preview a .textile file in a browser (render preview): >
  \rp
To render a .textile file as HTML to a new Vim tab: >
  \rt
To render a .textile file as HTML to a file: >
  \rf

Search the ~/hints.txt file: >
  :!~/bin/hint markdown
Search the ~/hints.txt file and put the output in vim: >
  :r !~/bin/hint markdown

Word completion from current buffer, forwards though list (INSERT MODE): >
  <C-X> <C-N>
Word completion from current buffer, backwards though list (INSERT MODE): >
  <C-X> <C-P>
Filename completion from current directory (INSERT MODE): >
  <C-X> <C-F>
Filename completion from specified directory (INSERT MODE): >
  /path/path/<C-X> <C-F>
Line completion from current buffer (INSERT MODE): >
  <C-X> <C-L>
Omni (code) completion (INSERT MODE): >
  <C-X> <C-O>
Dictionary completion (INSERT MODE): >
  <C-X> <C-K>
Tags completion (ctags) (INSERT MODE): >
  <CL-X> <CL-]>
Vim command-line completion (INSERT MODE): >
  <C-X> <C-V>
Spelling suggestions completion (INSERT MODE): >
  <C-X> <s>
Cancel an in-progress completion (INSERT MODE): >
  <C-E>
More help with completions: >
  :h ins-completion

Pull current word onto search/command line: >
  /<C-R> <C-W>

Display hex, ascii value of character under cursor: >
  ga

Turn a dos file into a unix file: >
  :set ff=unix
Turn a unix file into a dos file: >
  :set ff=dos

Count columns, lines, words, chars and bytes in current buffer: >
  g<C-G>



Open the file /etc/profile on line 20 when clicked in a web browse [|mvim|]r: >
  mvim://open?url=file:///etc/profile&line=20

Open a tasklist (of TODOs, FIXMEs, etc): >
  \t

Change font (font:size): >
  :set guifont=Menlo:h11

underline current line with - for a Markdown header: >
  ,uu
underline current line with - for a Markdown header: >
  ,u-
underline current line with = for a Markdown header: >
  ,u=

Time the start up of Vim with a breakdown of what takes how long (from command
line!): >
  vim --startuptime TIMEOUTPUT.txt INPUT.EXT
For more on troubleshooting a vim startup: >
  :help --startuptime
  :help slow-start

Execute a normal command (for instance, in a function): >
  normal COMMAND
  normal d2w       ' EXAMPLE: Delete two words

Go back to last reference point/marker: >
  ''

See more info regarding a 'set' command: >
  :verbose set [something to set]
See what's mapped to , and what mapped it: >
  :verbose map ,
See what's mapped to \ and what mapped it: >
  :verbose map \

Change working directory to that of current file: >
  :cd %:p:h

when in an html file, this sets the compiler (then you can run :make on it): >
  :compiler tidy

Compile using the makefile: >
  :make <OPTIONS/TARGETS>
Do a ":make run" without having to hit enter when you return: >
  :silent make run
Open the quickfix window (automatically opened by :make if errors encountered): >
  :copen
Go to the next quickfix item: >
  :cn

Make a left-justified alignment on character "x" where "x" is: ,:<=@|# : >
  \tx
Make a right-justified alignment on character "x" where "x" is: ,:<=@# : >
  \Tx
Like \tx but swaps whitespace on the right of the x to their left: >
  \tsx

INVALUABLE help resource when making vim scripts: >
  :help vim-script-intro


Run helptags after adding a helpfile into .vim/doc/ (NOTE: I don't use this): >
  :helptags ~/.vim/doc
(I use pathogen's :Helptags instead!!!!)


Use the expression register for math (insert mode): >
  <C-R>=35+7<cr>
Use the expression reg to insert result of a command (insert mode): >
  <C-R>=system("date")<cr>


Do a replace using the previous /search term (since empty pattern defaults to last search pattern): >
  :%s//replace-with-this/


In insert mode, type a ½ (1/2) character (using digraphs): >
  <C-k> 12
In insert mode, type a æ (AE) character (using digraphs): >
  <C-k> ae
In insert mode, type an ö (o with umlaut) (using digraphs): >
  <C-k> o:
See a list of all digraphs: >
  :dig
See a searchable (help file) list of all digraphs: >
  :h digraph-table

Convert markdown links in the current buffer to [referenced][1] markdown links: >
  :%! formd -r
Convert markdown links in the current buffer to [inline](http:...) markdown links: >
  :%! formd -i

In normal mode, go back into visual mode and select what was previously selected: >
  gv


------------------------------------------------------------------------------
not formatted well below here:
------------------------------------------------------------------------------

<C-O>    : retrace your movements in file (old)
<C-I>    : retrace your movements in file (new)


Consider adding mappings for 'formd':
nmap <leader>fr :%! ~/bin/formd -r<CR>
nmap <leader>fi :%! ~/bin/formd -i<CR>

" You can also use ! on a visual selection. Select an area with one of the
visualmode
" commands, and then type !command to pipe the whole selection through
command. (Note
" that this is equivalent to :'<,'>!command). For example, after selecting
multiple lines
" with visualmode:
!sort            : Filters the lines through the sort program
!grep word       : delete all lines not containing 'word'

/fred\_.\{-}jim    : fred then anything then jim (over multiple lines)
/fred\_s\{-}jim    : fred then any whitespace (including newlines) then jim
/fred\|jim         : fred OR jim

Run file through an external program (eg php)
map <F9> :w<CR>:!c:/php/php.exe %<CR>

It's easy to insert a list of ascending numbers, for example:
:0put =range(11,15)
Here is a more elaborate example:
:for i in range(1,10) | put ='192.168.0.'.i | endfor

The following commands open the file name under the cursor:
  gf    open in the same window ("goto file")
  <c-w>f    open in a new window
  <c-w>gf    open in a new tab 
You can return to the previous buffer using Ctrl-^ or Ctrl-o. 

while in Insert mode, hit <C-w> to delete the previous word

dip and vip it.
Thats right, paragraph manipulation is as easy as three keys. I tend to just
use 'dip' and 'vip', but there have gotta be other good ones out there...
yip? yep.
grip? Rip? darn! No, that doesn't work. Changes you back into insert mode.
cip? okay, yes.
g?ip? Yes, kinda silly though.
>ip? yes.
'ip' is just inner paragraph. You could do various kinds of inner blocks and
quotes. 
SO:
  dip   #delete paragraph cursor is currently in
  vip   #select paragraph cursor is currently in
  cip   #replace paragraph cursor is currently in
  yip   #yank paragraph cursor is currently in

Here's a little Vim trick that might be of interest. If you're on a
non-Windows machine, you can make the Vim hardcopy command print to a
postscript file instead of a real printer. Try issue the following:
  :hardcopy > file.ps
You'll get a postscript output of the file you're currently editing.
From there you can view the postscript file with gv or convert it to a pdf
with ps2pdf.


You may have noticed that pasting outside text into Vim from insert mode can
lead to awkwardly stair-stepped text. You may also know that this is easily
avoidable via :set paste from normal mode. I paste from outside often enough,
that I've added the following to my vimrc making it that much easier.
  set pastetoggle=<F5>
(i might want to map it to ,pp)

Scenario: ~
Typing feels sluggish when the cursor is just before a right bracket (i.e. ')',
'}', or ']').
Solution: ~
Disable the "matchparen" plugin (see |matchparen|) by typing :NoMatchParen.
If that helps, then you can permanently disable "matchparen" by adding the
following line to your "~/.vimrc": >
	let loaded_matchparen=1

to add single-level folding:
add "fdm=marker" to the modeline (or turn folding on in prefs)
and add "{{{1" to the end of each section title
these folds will fold until the next "{{{1" is found
or use {{{ and }}} instead to explicitly define start and end of fold

to fold on the fly:
in visual mode, select some lines and then hit "zf" to fold them

to fold braces on the fly, go to the first brace and hit "zfa}", or to the last brace and
hit "zfa{" -- this also works for [] and <> and ()

you can create a fold from the cursor position to a search result on the fly. If you run
zf/string , Vim will create a fold from the cursor position to the first
instance of the search string.

":set foldmethod=indent" to fold each indented level
(might be good for an everything.txt file!!)
(or "set fdm=indent")
other fold methods:
  manual    manually define folds
  indent    more indent means a higher fold level
  expr      specify an expression to define folds
  syntax    folds defined by syntax highlighting
  diff      folds for unchanged text
  marker    folds defined by markers in the text

:set ai         autoindent on
:set ff=unix    set fileformat to unix
:set ic         ignore case when searching.
:set list       display tabs and carriage returns
:set nu         display line numbers
:set sm         show matching brace or parenthesis while inserting
:set smd        display the mode
:set sw=2       set shifting to 2 spaces
:set tabstop=4  set tabs to 4 spaces

work through this and add whichever ones I need:
http://www.brezeale.com/technical_notes/vim_notes.shtml


An easier-to-remember way:
Go to desired start line, hit ma ("mark this line as 'a'"), then go to desired end line, and hit y'a or d'a ("yank or delete to the line marked 'a'"). Paste using p.
A character-level way: (not line-level)
Go to desired start character, hit ma (same as above), then go to desired end character (can be in a different line), and hit y`a or d`a (notice that it's the "tick", not the "apostrophe"). Paste using p.





ci or di. Delete/replace everything between a delimiter.

system("echo Hello World!");
If your cursor is on the H, di" would delete everything between the quotes.




bookmarks.
ma and 'a
use m to mark a location and save it to some key (a in this case). Later, when you want to return to that location, hit 'a and you will be taken to bookmark a. Can have many bookmarks active at the same time, tied to different keys.


In insert mode, ctrl+w deletes the previous word.
Useful when you mistype a word, just ctrl+w and retype it - quicker than using backspace, or having to exit insert mode, delete the word and return to insert mode..


Reformat Paragraph
gq}


The one I wish I'd discovered long ago is using Ctrl-C instead of Esc to switch out of insert mode. I've always found that reaching up to the Esc key is less than optimal for productivity, so I was glad to learn this.


:.!COMMAND to run a command and insert its output at the cursor's current position


gg=G
indent everything...




Find yourself typing a path in all the time? Make it a variable. I like to keep my sessions all in a directory of their own, but my fingers hate the typing to load them up. Now, my sessions directory is just referenced as $S.
  let $S = $HOME . '/.vim/sessions'  (in your .vimrc)
  :so $S/sessionname                 (from the command prompt in vim)
Tab complete even works after you've typed $S/. So much nicer.

Vim also supplies you with some fancy ways to do dynamic replacing of text as you type it. Most people like to use this feature to automatically fix common misspellings. I tend to use it as more of a "mini macro" expression.
  iabbrev {{DATE}} <C-R>=strftime("%A, %B %e %Y @ %r")<CR>
  iabbrev {{EPOCH}} <C-R>=strftime("%s")<CR>
  iabbrev {{UUID}} <ESC>!!uuidgen<CR>guu



Use sessions.
While we're talking about session automation, it took me awhile before appreciating the beauty of this feature. A session is like a marshalled editing environment. Source it, and everything you were working on previously comes right back up, right down to your cursor position.
What makes this even nicer is a quick shortcut like so:
  map <F8> :execute 'mksession! ' . v:this_session<CR>
If you're inside a session, hitting F8 will re-save any environmental changes you've made out to the same session file.

save session:
  :mksession ~/mysession.vim
load session (from in vim):
  :source ~/mysession.vim
load session (from command line):
  vim -S ~/mysession.vim


study:
:h windows
:h tab-page
:h text-objects


scoped within your current file:
Put the cursor over a variable or method, and type gd in command mode. This is saying Go to Declaration, and you'll jump to where the variable or method is originally defined.

Go to File:
If what you're hovering over is a path to a file on disk, type gf and you'll jump directly into that file. This works for a lot of syntax modes, too -- for example, calling gf on a ruby 'require' line will jump into the required file.

an external utility, called ctags:
Ctags creates an index across your entire project, defining declaration locations for everything. From any file, you can hit C-] while your cursor is over what you want to lookup. You'll jump directly to the declaration, even if it is in a different file. Super slick. If there are multiple matches, I also like to add a keybinding to this:
map <C-\> :tselect /<C-R><C-W>
Which presents you with a list of matching destinations that you can choose from.


normal undo is u
<C-r> is redo
Using :undolist you can have a look at the possible undo states. With :earlier 20s / 1m / 2h you can then go back 20 seconds, one minute etc.
Traveling forward in time works using :later and a timedelta as argument.


If you searched using /foo Just do :%s/<c-r>//replacement/g and <c-r> is automatically replaced with the last search regular expression.


just bookmark it with mX where X is a lowercase letter from a to z
Go to that mark using 'X
Using '' you can jump back to the position you were before jumping to the bookmark
You can get the list of bookmarks using :marks

wildmenu
Enter :e in the command line and press ^D
If it was a folder you can now press ^D again to get the contents



in the vim help see :he text-objects for more stuff like diw or vi)



On a character in the first line, press Ctrl-V (or Ctrl-Q if Ctrl-V is paste).
Press jj to extend the visual block over three lines.
Press $ to extend the visual block to the end of each line.


block select something with CTRL-V and then press I or A to insert or append at the same spot on each line.


(in insert mode)
CTRL-E		Insert the character which is below the cursor.  {not in Vi}

(in insert mode)
CTRL-Y		Insert the character which is above the cursor.  {not in Vi}
		Note that for CTRL-E and CTRL-Y 'textwidth' is not used, to be
		able to copy characters from a long line.


for markdown:
  nnoremap <Leader>H yyp^v$r-o<Esc>
For example, if you start with this text...
This Is A Title
...then type \H on the "This Is A Title" line, you'll get this:
This Is A Title
---------------


:map \                             " list maps beginning with \
:map ,                             " list maps beginning with ,




!!date           : Replaces current line with date
!!which 'command': Replace current line with the absolute path to 'command'
!!tr -d abcd     : Delete a,b,c,d from the current line

(in visual mode:)
!sort            : Filters the lines through the sort program
(in visual mode:)
!grep word       : delete all lines not containing 'word'


:sav php.html : Save current file as php.html and "move" to php.html
:e!           : return to unmodified file


:g/^\s*$/d       : delete all blank lines
:g!/^dd/d        : delete lines not containing string
:v/^dd/d         : delete lines not containing string
:v/./.,/./-1join : compress empty lines


Searching over multiple lines: \_ includes newline
:h \_              : help


noremap <C-kPlus> <C-A>
in your vimrc. Then you can use Ctrl-NumPad+ to increment numbers as others do with Ctrl-A.


To highlight the current line, and have the highlighting stay where it is while you move the cursor, use this mapping:
:nnoremap <silent> <Leader>k mk:exe 'match Search /<Bslash>%'.line(".").'l/'<CR>
This mapping also sets mark k, so that you can simply press 'k to return to the highlighted line. Use :match to clear the highlighting once you're done.


http://vim.wikia.com/wiki/Highlight_long_lines


da<
Delete the HTML tag the cursor is currently inside of Ð the whole tag, regardless of just where the cursor is.

ci"
Change the content of a doublequote-delimited string.

vi'    -> Visual select everything inside '' string
ya(    -> Yank all text from ( to )


:g/rgba/y A
will yank all lines containing "rgba" into the a buffer. I used it a lot recently when making Internet Explorer stylesheets.


Assuming you have Perl and/or Ruby support compiled in, :rubydo and :perldo will run a Ruby or Perl one-liner on every line in a range (defaults to entire buffer), with $_ bound to the text of the current line (minus the newline). Manipulating $_ will change the text of that line.
  You can use this to do certain things that are easy to do in a scripting language but not so obvious using Vim builtins. For example to reverse the order of the words in a line:
  :perldo $_ = join ' ', reverse split
To insert a random string of 8 characters (A-Z) at the end of every line:
  :rubydo $_ += ' ' + (1..8).collect{('A'..'Z').to_a[rand 26]}.join
You are limited to acting on one line at a time and you can't add newlines.


Only on Mac OS X: Safari-like tab navigation:
  map <S-D-Right> :tabnext<cr>
  map <S-D-Left> :tabprevious<cr>


Don't look up that fact you read on wikipedia, have it directly pasted into the document you are writing:
  :r! lynx -dump http://en.wikipedia.org/wiki/Whatever




I was sure someone would have posted this already, but here goes.
Take any build system you please; make, mvn, ant, whatever. In the root of the project directory, create a file of the commands you use all the time, like this:
  mvn install
  mvn clean install
  ... and so forth
To do a build, put the cursor on the line and type !!sh. I.e. filter that line; write it to a shell and replace with the results.
The build log replaces the line, ready to scroll, search, whatever.
When you're done viewing the log, type u to undo and you're back to your file of commands.


I often want to highlight a particular word/function name, but don't want to search to the next instance of it yet:
  map m* *#


^Z or :sh
Move temporary to the shell. If you need a quick bashing:
  press ^Z (to put vi in background) to return to original shell and press fg to return to vim back
  press :sh to go to sub shell and press ^D/exit to return to vi back



If you open a file in Vim, make some changes, then want to check those changes compared to when you opened it (do a diff before saving), then you have a few options:
:w !diff % -


to draw boxes:
  <C-V>   to make a visual selection box,
  then hit \d
Note: I strongly recommend ":set virtualedit+=block" when using this script, so you can define rectangles beyond the end of the line.




Syntax highlighting for HTML with embedded Javascript:
Just use the "htmlm4.vim" syntax script.
Put simply, while in normal mode, type the following:
:set filetype=htmlm4
(not sure if this actually works!)


Suppose you have typed <div> and you want to close it without typing the whole
closing tag </div> yourself.  You could quickly close the tag by typing </ and
pressing CTRL+X CTRL+O. The default Vim mapping CTRL+X CTRL+O guesses the item
that may come after the cursor. In case of an open HTML tag it's the close
tag.

To have vim keep a logfile/errorlog, start vim as:
  vim -V9myVimLog
(where '9' is the verbosity level and  'myVimLog' is the name of the logfile)

za      - toggle current fold
zi      - toggle current fold (what's the difference?)

(Idea: Temporarily ":map <LocalLeader>, @q" (or any macro letter) so that you can just press "," to repeat it.)
(or: ":nnoremap <Space> @q")


Find out what highlight group the word under the cursor belongs to: >
  :echo synIDattr(synID(line("."),col("."),1),"name")

See the settings for a highlight group: >
  :hi GROUPNAME

See a list of most recently used files, with option to select one: >
  :browse oldfiles


Might need to to force Markdown without installing from this repository, add the following to your vimrc:
  autocmd BufNewFile,BufReadPost *.md set filetype=markdown




Plugins I Might Want To Add, Sometime:
--------------------------------------
https://github.com/tpope/vim-repeat     (add ability to .-repeat some plugins)
https://github.com/tpope/vim-surround   (add/remove surrounding tags/brackets)
https://github.com/tpope/vim-git        (highlight some git-specific things)
https://github.com/othree/html5.vim     (better html5 highlighting?)
https://github.com/pangloss/vim-javascript      (better js highlighting?)
https://github.com/sophacles/vim-processing     (better p5 highlighting?)
https://github.com/majutsushi/tagbar    (neat tag list, but i never used it)
https://github.com/lepture/vim-css              (better css highlighting?)
https://github.com/hail2u/vim-css3-syntax       (better css highlighting?)
https://github.com/elzr/vim-json        (better json highlighting)


==============================================================================
vim:tw=78:ts=8:ft=help:norl:set noreadonly:set modifiable:
